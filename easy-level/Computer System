# ğŸ–¥ï¸ Computer System: The Hourglass Model

Think of the system as an hourglass:  
Lots of apps at the top, lots of hardware at the bottom, and a narrow waist where everything standardizes so they can all interoperate.

---

## ğŸ“š Layer Overview

    Apps["Apps (editors, browsers, games, your programs)"]
    Runtime["Language runtime & stdlib (Python/Java VM, libc, .NET, Node.js)"]
    Syscall["System call interface (open, read, write, socket, ioctlâ€¦)"]
    Kernel["Operating system kernel (scheduling, memory mgmt, filesystems, networking)"]
    Drivers["Device drivers (NIC, GPU, storage, keyboard, IÂ²C controllersâ€¦)"]
    Firmware["Firmware (UEFI/BIOS, disk controller firmware, GPU/SSD firmware, microcode)"]
    Hardware["Hardware (CPU, RAM, SSD/HDD, GPU, NIC, sensors; buses like PCIe, USB, IÂ²C, SPI)"]


    Apps --> Runtime --> Syscall --> Kernel --> Drivers --> Firmware --> Hardware


---

ğŸ·ï¸ What Each Layer Does

- Apps: Your logic and UI.
- Runtime/stdlib: Convenience wrappers (e.g., `fopen`, `socket`) and managed runtimes.
- System calls: The only official door from user programs into the OS kernel.
- Kernel: Referee of CPU time, memory, files, and network; exposes uniform abstractions.
- Drivers: Per-device translators between kernel abstractions and real hardware registers.
- Firmware: On-device software that makes the hardware usable (e.g., SSD wear leveling).
- Hardware: The electronics doing the work; connected by buses (PCIe/USB/IÂ²C/SPI).

---

ğŸ”— How Layers Talk (Fast but Accurate)

1. Function call (in your code) â†’ into a library (e.g., `printf` â†’ `write`).
2. Library requests a system call (switches CPU to kernel mode via a trap instruction).
3. Kernel validates arguments, touches the right subsystem (files, network, etc.).
4. If hardware work is needed, the driver:
    - Writes/reads memory-mapped registers or special I/O ports.
    - Sets up DMA (device moves data directly to RAM).
    - Enables interrupts so the device can say â€œIâ€™m done!â€
5. When the device finishes:
    - It raises an interrupt â†’ kernel runs a quick handler, wakes any waiting process.
    - You get control back in user space with a return value.

---






ğŸ“– Two â€œStoriesâ€ That Make the Map Stick




### 1ï¸âƒ£ From Keypress to Letter on Screen

1. You press a key â†’ keyboardâ€™s microcontroller sends a code (USB/Bluetooth).
2. USB/BT controller hardware receives it â†’ triggers an interrupt.
3. Kernel HID driver parses the scancode â†’ posts an event to the OS input queue.
4. Window system (Wayland/X11/Quartz/Win32) routes the event to your focused app.
5. Your appâ€™s GUI toolkit calls your callback (e.g., `onKeyDown('A')`).
6. When you draw text, the graphics stack (DirectX/Vulkan/OpenGL) talks to the GPU driver â†’ GPU renders â†’ display scans out the frame buffer â†’ you see â€œAâ€.

Layers used:
`app â†’ GUI/runtime â†’ syscalls â†’ kernel input subsystem â†’ HID driver â†’ GPU driver â†’ hardware`

---


2ï¸âƒ£ From Saving a File to Bytes on Disk

1. App calls `write()` â†’ syscall into kernel.
2. Kernel writes to the page cache (RAM) and updates your filesystem (ext4, NTFS, APFS).
3. Filesystem code emits block I/O requests â†’ storage driver (NVMe/SATA/USB).
4. Driver programs the controller (often via MMIO) and sets up DMA.
5. SSD/HDD firmware does the real work (flash translation layer, ECC, wear leveling).
6. Device raises an interrupt to confirm completion; kernel may later flush to ensure durability (e.g., `fsync`).

**Layers used:**  
`app â†’ libc â†’ syscalls â†’ VFS/filesystem â†’ block layer â†’ storage driver â†’ disk firmware â†’ hardware`




---







ğŸ—ï¸ Key Vocabulary (Plain-English)

- User mode / Kernel mode: Two privilege levels; user mode canâ€™t touch hardware directly.
- System call (syscall): A controlled door into the kernel (`open`, `read`, `mmap`, `ioctl`).
- Interrupt: Hardwareâ€™s way to asynchronously say â€œhey, something happened.â€
- DMA (Direct Memory Access): Device writes/reads RAM without burdening the CPU.
- MMU & virtual memory: Hardware + kernel give each process its own address space (safety).
- Scheduler: Chooses which thread runs next on the CPU.
- Bus: The road that moves bits between chips (PCIe/USB on PCs; IÂ²C/SPI inside gadgets).
- Firmware: Software shipped inside a device (SSD, GPU, Wi-Fi card) that the OS drivers talk to.
